# Kurubind

**Kurubind** es una librer√≠a ligera que act√∫a como puente entre clases anotadas y JDBI, proporcionando operaciones CRUD autom√°ticas, validaci√≥n de datos, generaci√≥n de valores, y un sistema extensible mediante handlers y generadores SQL.

## üéØ Caracter√≠sticas Principales

- ‚úÖ **Operaciones CRUD autom√°ticas** sin SQL repetitivo
- ‚úÖ **Validaci√≥n de datos integrada** con validators extensibles
- ‚úÖ **Generaci√≥n autom√°tica de valores** (UUID, timestamps, c√≥digos)
- ‚úÖ **Sistema de handlers** para transformar datos
- ‚úÖ **Soporte multitenancy** mediante JdbiProvider
- ‚úÖ **SQL manual** cuando necesitas control total
- ‚úÖ **Ligera y no intrusiva** - solo depende de JDBI

## üöÄ Quick Start

### 1. Definir una Entidad

```java
@Table(name = "products")
public class Product {
    @Id
    @Column("id")
    private Long id;

    @Column("name")
    private String name;

    @Column("price")
    private Double price;

    @Column("active")
    @DefaultValue(value = "true")
    private Boolean active;

    // Getters y setters
}
```

### 2. Configurar KurubindDatabase

```java
Jdbi jdbi = Jdbi.create("jdbc:postgresql://localhost:5432/mydb");

KurubindDatabase db = KurubindDatabase.builder()
    .withJdbi(jdbi)
    .build();
```

### 3. Usar Operaciones CRUD

```java
// Insertar
Product product = new Product();
product.setName("Laptop");
product.setPrice(999.99);

try {
    db.insert(product);
    System.out.println("ID generado: " + product.getId());
} catch (ValidationException e) {
    e.getErrors().forEach(err -> 
        System.err.println(err.getFieldName() + ": " + err.getMessage())
    );
}

// Actualizar
product.setPrice(899.99);
db.update(product);

// Listar
List<Product> products = db.list(Product.class);

// Eliminar
db.delete(product);
```

## üìö Anotaciones Base

### Entidades

| Anotaci√≥n | Uso | Ejemplo |
|-----------|-----|---------|
| `@Table` | Define tabla y schema | `@Table(name = "users", schema = "public")` |
| `@Column` | Mapea campo a columna | `@Column("username")` |
| `@Id` | Marca llave primaria | `@Id(autoGenerated = true)` |
| `@Transient` | Ignora campo | `@Transient` |
| `@QueryResponse` | Marca DTO para queries | `@QueryResponse` |

### Generaci√≥n de Valores

| Anotaci√≥n | Descripci√≥n | Ejemplo |
|-----------|-------------|---------|
| `@DefaultValue` | Valor por defecto (literal o generator) | `@DefaultValue(value = "ACTIVE")` |
| `@Generated` | Generaci√≥n autom√°tica con control fino | `@Generated(generator = "UUID", onInsert = true)` |

## üîß Value Generators

Los value generators permiten generar valores autom√°ticamente:

```java
// 1. Crear generator
public class UuidGenerator implements ValueGenerator {
    public Object generate(Object entity, FieldMetadata field) {
        return UUID.randomUUID().toString();
    }
    
    public boolean generateOnInsert() { return true; }
    public boolean generateOnUpdate() { return false; }
}

// 2. Registrar
ValueGeneratorRegistry generatorRegistry = new ValueGeneratorRegistry();
generatorRegistry.register("UUID", new UuidGenerator());

// 3. Usar en entidad
@Column("uuid")
@DefaultValue(generator = "UUID")
private String uuid;
```

### Generators Incluidos

- `UuidGenerator` - Genera UUIDs
- `CreatedAtGenerator` - Timestamp de creaci√≥n
- `UpdatedAtGenerator` - Timestamp de actualizaci√≥n
- `PrefixedCodeGenerator` - C√≥digos con prefijo personalizable


### Validaci√≥n Acumulativa

Kurubind acumula **todos** los errores antes de lanzar la excepci√≥n:

```java
Product invalid = new Product();
invalid.setName(null);     // Error 1
invalid.setPrice(-100.0);  // Error 2
invalid.setStock(15000);   // Error 3

try {
        db.insert(invalid);
} catch (ValidationException e) {
        // Obtiene los 3 errores juntos
        for (ValidationError error : e.getErrors()) {
        System.err.println(error.getFieldName() + ": " + error.getMessage());
        }
        }
```

### Validators Custom

```java
// 1. Crear anotaci√≥n
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Email {
    String message() default "Invalid email";
}

// 2. Implementar validator
public class EmailValidator implements Validator {
    private static final Pattern EMAIL_PATTERN =
            Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");

    public void validate(Object value, FieldMetadata field) {
        if (value != null && !EMAIL_PATTERN.matcher(value.toString()).matches()) {
            throw new ValidationException(getErrorMessage(value, field));
        }
    }

    public String getErrorMessage(Object value, FieldMetadata field) {
        return "Invalid email: " + value;
    }
}

// 3. Registrar
validatorRegistry.register(Email.class, new EmailValidator());
```

## üîÑ Handlers

Los handlers transforman datos entre Java y la base de datos:

```java
// Handler para JSON
public class JsonHandler implements Handler {
    private final ObjectMapper objectMapper = new ObjectMapper();

    public Object handleWrite(Object javaValue) {
        return objectMapper.writeValueAsString(javaValue);
    }

    public Object handleRead(Object dbValue) {
        return objectMapper.readValue(dbValue.toString(), Map.class);
    }
}

// Registrar
handlerRegistry.register(JsonColumn.class, new JsonHandler());

// Usar
@JsonColumn("metadata")
private Map<String, Object> metadata;
```

## üóÉÔ∏è Repository Pattern

```java
public class ProductRepository extends Repository<Product> {
    public ProductRepository(KurubindDatabase db) {
        super(db, Product.class);
    }

    public List<Product> findActiveProducts() {
        return query("SELECT * FROM products WHERE active = true");
    }

    public List<Product> findByPriceRange(double min, double max) {
        return db.query(
                "SELECT * FROM products WHERE price BETWEEN :min AND :max",
                Product.class
        );
    }
}

// Uso
ProductRepository repo = new ProductRepository(db);
List<Product> active = repo.findActiveProducts();
```

## üé® SQL Generators

Optimiza SQL para dialectos espec√≠ficos:

```java
public class PostgreSQLGenerator implements SQLGenerator {
    public String generateInsert(EntityMetadata meta, List<FieldMetadata> fields) {
        // ... generar SQL
        if (meta.hasAutoGeneratedId()) {
            sql += " RETURNING " + meta.getIdField().getColumnName();
        }
        return sql;
    }

    public String getPlaceholder(FieldMetadata field) {
        String placeholder = ":" + field.getColumnName();
        if (field.hasAnnotation(JsonColumn.class)) {
            placeholder += "::jsonb";
        }
        return placeholder;
    }
}

// Registrar
sqlGeneratorRegistry.register(
    new Dialect("POSTGRESQL"),
    new PostgreSQLGenerator()
);
```

## üè¢ Multitenancy

```java
JdbiProvider multitenantProvider = () -> {
    String tenantId = TenantContext.getCurrentTenant();
    return tenantConnectionPool.getJdbi(tenantId);
};

KurubindDatabase db = KurubindDatabase.builder()
        .withJdbiProvider(multitenantProvider)
        .build();

// Usar
TenantContext.setTenant("tenant1");
db.insert(product); // Se inserta en tenant1_db
```

## üìä DTOs para Queries

```java
@QueryResponse
public class ProductSummary {
    @Column("id")
    private Long id;

    @Column("total_value")
    private Double totalValue;
}

List<ProductSummary> summary = db.query("""
            SELECT id, (price * stock) as total_value 
            FROM products
        """, ProductSummary.class);
```

## üîÑ Flujo de Operaciones

### INSERT
1. Generar valores (`@DefaultValue`, `@Generated`)
2. Validar datos (acumular errores)
3. Transformar datos (handlers)
4. Ejecutar SQL
5. Recuperar ID generado

### UPDATE
1. Generar valores (`@Generated` con `onUpdate=true`)
2. Validar datos
3. Transformar datos
4. Ejecutar SQL

## ‚öôÔ∏è Configuraci√≥n Completa

```java
// JDBI
Jdbi jdbi = Jdbi.create("jdbc:postgresql://localhost:5432/mydb");

// Handlers
HandlerRegistry handlerRegistry = new HandlerRegistry();
handlerRegistry.register(JsonColumn.class, new JsonHandler());

// SQL Generators
SQLGeneratorRegistry sqlRegistry = new SQLGeneratorRegistry();
sqlRegistry.register(new Dialect("POSTGRESQL"), new PostgreSQLGenerator());

// Validators (los base ya est√°n incluidos)
ValidatorRegistry validatorRegistry = new ValidatorRegistry();
validatorRegistry.register(Email.class, new EmailValidator());

// Value Generators
ValueGeneratorRegistry generatorRegistry = new ValueGeneratorRegistry();
generatorRegistry.register("UUID", new UuidGenerator());
        generatorRegistry.register("CREATED_AT", new CreatedAtGenerator());
        generatorRegistry.register("UPDATED_AT", new UpdatedAtGenerator());

// Build
KurubindDatabase db = KurubindDatabase.builder()
        .withJdbi(jdbi)
        .withHandlerRegistry(handlerRegistry)
        .withSQLGeneratorRegistry(sqlRegistry)
        .withValidatorRegistry(validatorRegistry)
        .withValueGeneratorRegistry(generatorRegistry)
        .withDialect(new Dialect("POSTGRESQL"))
        .build();
```

## üéØ Filosof√≠a

Kurubind **NO es un ORM completo**. Es una capa delgada sobre JDBI que:

‚úÖ Elimina SQL repetitivo para operaciones comunes  
‚úÖ Permite SQL manual cuando se necesita control total  
‚úÖ Se extiende mediante interfaces claras  
‚úÖ Proporciona validaci√≥n y generaci√≥n de valores integradas  
‚ùå No tiene lazy loading, cascadas, ni cache  
‚ùå No impone restricciones ni frameworks adicionales

## üìù Licencia

MIT License

## ü§ù Contribuciones

Las contribuciones son bienvenidas. Por favor, abre un issue primero para discutir cambios importantes.

---