package com.roelias.kurubind;

import com.roelias.kurubind.annotations.DefaultValue;
import com.roelias.kurubind.annotations.Generated;
import com.roelias.kurubind.core.*;
import com.roelias.kurubind.exceptions.ValidationError;
import com.roelias.kurubind.exceptions.ValidationException;
import com.roelias.kurubind.mapper.KurubindRowMapper;
import com.roelias.kurubind.metadata.EntityMetadata;
import com.roelias.kurubind.metadata.FieldMetadata;
import com.roelias.kurubind.registry.HandlerRegistry;
import com.roelias.kurubind.registry.SQLGeneratorRegistry;
import com.roelias.kurubind.registry.ValidatorRegistry;
import com.roelias.kurubind.registry.ValueGeneratorRegistry;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.mapper.RowMapper;
import org.jdbi.v3.core.statement.Call;
import org.jdbi.v3.core.statement.Query;
import org.jdbi.v3.core.statement.Update;

import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class KurubindDatabase {
    private final JdbiProvider jdbiProvider;
    private final HandlerRegistry handlerRegistry;
    private final SQLGeneratorRegistry sqlGeneratorRegistry;
    private final ValidatorRegistry validatorRegistry;
    private final ValueGeneratorRegistry valueGeneratorRegistry;
    private final Dialect dialect;

    private KurubindDatabase(Builder builder) {
        this.jdbiProvider = builder.jdbiProvider;
        this.handlerRegistry = builder.handlerRegistry;
        this.sqlGeneratorRegistry = builder.sqlGeneratorRegistry;
        this.validatorRegistry = builder.validatorRegistry;
        this.valueGeneratorRegistry = builder.valueGeneratorRegistry;
        this.dialect = builder.dialect;
    }

    // ========== CRUD Operations ==========

    public <T> void insert(T entity) {
        EntityMetadata metadata = new EntityMetadata(entity.getClass());
        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot insert @QueryResponse entities");
        }
        generateValues(entity, metadata, true, false);
        validateEntity(entity, metadata);
        List<FieldMetadata> fieldsToInsert = getFieldsForInsert(metadata);
        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateInsert(metadata, fieldsToInsert);
        execute(handle -> {
            Update update = handle.createUpdate(sql);
            bindFields(update, entity, fieldsToInsert);

            if (metadata.hasAutoGeneratedId()) {
                Object generatedId = update.executeAndReturnGeneratedKeys(metadata.getIdField().getColumnName())
                        .mapTo(metadata.getIdField().getFieldType())
                        .one();
                metadata.getIdField().setValue(entity, generatedId);
            } else {
                update.execute();
            }
        });
    }

    public <T> void insertAll(List<T> entities) {
        if (entities.isEmpty()) return;

        EntityMetadata metadata = new EntityMetadata(entities.get(0).getClass());
        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot insert @QueryResponse entities");
        }

        // Validate all entities first
        for (T entity : entities) {
            generateValues(entity, metadata, true, false);
            validateEntity(entity, metadata);
        }

        List<FieldMetadata> fieldsToInsert = getFieldsForInsert(metadata);
        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateInsert(metadata, fieldsToInsert);

        execute(handle -> {
            for (T entity : entities) {
                Update update = handle.createUpdate(sql);
                bindFields(update, entity, fieldsToInsert);

                if (metadata.hasAutoGeneratedId()) {
                    Object generatedId = update.executeAndReturnGeneratedKeys(metadata.getIdField().getColumnName())
                            .mapTo(metadata.getIdField().getFieldType())
                            .one();
                    metadata.getIdField().setValue(entity, generatedId);
                } else {
                    update.execute();
                }
            }
        });
    }

    public <T> void update(T entity) {
        EntityMetadata metadata = new EntityMetadata(entity.getClass());

        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot update @QueryResponse entities");
        }

        if (!metadata.hasIdField()) {
            throw new IllegalArgumentException("Entity must have @Id field for update");
        }

        generateValues(entity, metadata, false, true);
        validateEntity(entity, metadata);

        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateUpdate(metadata, metadata.getFields());

        execute(handle -> {
            Update update = handle.createUpdate(sql);
            bindFields(update, entity, metadata.getNonIdFields());
            update.bind(metadata.getIdField().getColumnName(),
                    metadata.getIdField().getValue(entity));
            update.execute();
        });
    }

    public <T> void updateAll(List<T> entities) {
        for (T entity : entities) {
            update(entity);
        }
    }

    public <T> void delete(T entity) {
        EntityMetadata metadata = new EntityMetadata(entity.getClass());

        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot delete @QueryResponse entities");
        }

        if (!metadata.hasIdField()) {
            throw new IllegalArgumentException("Entity must have @Id field for delete");
        }

        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateDelete(metadata);

        execute(handle -> {
            handle.createUpdate(sql)
                    .bind(metadata.getIdField().getColumnName(),
                            metadata.getIdField().getValue(entity))
                    .execute();
        });
    }

    public <T> void deleteAll(List<T> entities) {
        for (T entity : entities) {
            delete(entity);
        }
    }

    public <T> void deleteById(Class<T> entityClass, Object id) {
        EntityMetadata metadata = new EntityMetadata(entityClass);

        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot delete @QueryResponse entities");
        }

        if (!metadata.hasIdField()) {
            throw new IllegalArgumentException("Entity must have @Id field for delete");
        }

        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateDelete(metadata);

        execute(handle -> {
            handle.createUpdate(sql)
                    .bind(metadata.getIdField().getColumnName(), id)
                    .execute();
        });
    }

    public <T> void deleteByIds(Class<T> entityClass, List<Object> ids) {
        for (Object id : ids) {
            deleteById(entityClass, id);
        }
    }

    // ========== Query Operations ==========

    public <T> List<T> list(Class<T> entityClass) {
        EntityMetadata metadata = new EntityMetadata(entityClass);

        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot list @QueryResponse entities. Use query() instead.");
        }

        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateSelect(metadata);

        return query(sql, entityClass);
    }

    public <T> Optional<T> queryById(Class<T> entityClass, Object id) {
        EntityMetadata metadata = new EntityMetadata(entityClass);

        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot queryById @QueryResponse entities. Use query() instead.");
        }

        if (!metadata.hasIdField()) {
            throw new IllegalArgumentException("Entity must have @Id field for queryById");
        }

        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateSelectById(metadata);

        KurubindRowMapper<T> mapper = new KurubindRowMapper<>(
                entityClass, handlerRegistry, dialect
        );

        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createQuery(sql)
                        .bind("id", id)
                        .map(mapper).findOne()
        );
    }

    public <T> List<T> queryByIds(Class<T> entityClass, List<Object> ids) {
        if (ids.isEmpty()) return Collections.emptyList();

        List<T> results = new ArrayList<>();
        for (Object id : ids) {
            queryById(entityClass, id).ifPresent(results::add);
        }
        return results;
    }

    public <T> Optional<T> queryFirst(Class<T> entityClass) {
        List<T> results = list(entityClass);
        return results.isEmpty() ? Optional.empty() : Optional.of(results.get(0));
    }

    public <T> boolean exists(Class<T> entityClass, Object id) {
        return queryById(entityClass, id).isPresent();
    }

    public Long count(Class<?> entityClass) {
        EntityMetadata metadata = new EntityMetadata(entityClass);

        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot count @QueryResponse entities.");
        }

        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateCount(metadata);

        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createQuery(sql)
                        .mapTo(Long.class)
                        .one()
        );
    }

    public <T> List<T> query(String sql, Class<T> resultClass) {
        KurubindRowMapper<T> mapper = new KurubindRowMapper<>(
                resultClass, handlerRegistry, dialect
        );

        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createQuery(sql)
                        .map(mapper)
                        .list()
        );
    }

    public <T> List<T> query(String sql, Class<T> resultClass, Map<String, Object> params) {
        KurubindRowMapper<T> mapper = new KurubindRowMapper<>(
                resultClass, handlerRegistry, dialect
        );

        return jdbiProvider.getJdbi().withHandle(handle -> {
            Query query = handle.createQuery(sql);
            params.forEach(query::bind);
            return query.map(mapper).list();
        });
    }

    public <T> Optional<T> queryOne(String sql, Class<T> resultClass) {
        KurubindRowMapper<T> mapper = new KurubindRowMapper<>(
                resultClass, handlerRegistry, dialect
        );

        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createQuery(sql)
                        .map(mapper)
                        .findOne()
        );
    }

    public <T> Optional<T> queryOne(String sql, Class<T> resultClass, Map<String, Object> params) {
        KurubindRowMapper<T> mapper = new KurubindRowMapper<>(
                resultClass, handlerRegistry, dialect
        );

        return jdbiProvider.getJdbi().withHandle(handle -> {
            Query query = handle.createQuery(sql);
            params.forEach(query::bind);
            return query.map(mapper).findOne();
        });
    }

    public <T> Stream<T> queryStream(String sql, Class<T> resultClass) {
        KurubindRowMapper<T> mapper = new KurubindRowMapper<>(
                resultClass, handlerRegistry, dialect
        );

        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createQuery(sql)
                        .map(mapper)
                        .stream()
                        .collect(Collectors.toList())
                        .stream()
        );
    }

    // ========== Raw Query Operations ==========

    public List<Map<String, Object>> queryForMaps(String sql) {
        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createQuery(sql)
                        .mapToMap()
                        .list()
        );
    }

    public List<Map<String, Object>> queryForMaps(String sql, Map<String, Object> params) {
        return jdbiProvider.getJdbi().withHandle(handle -> {
            Query query = handle.createQuery(sql);
            params.forEach(query::bind);
            return query.mapToMap().list();
        });
    }

    public Optional<Map<String, Object>> queryForMap(String sql) {
        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createQuery(sql)
                        .mapToMap()
                        .findOne()
        );
    }

    public Optional<Map<String, Object>> queryForMap(String sql, Map<String, Object> params) {
        return jdbiProvider.getJdbi().withHandle(handle -> {
            Query query = handle.createQuery(sql);
            params.forEach(query::bind);
            return query.mapToMap().findOne();
        });
    }

    // ========== Scalar Query Operations ==========

    public <T> Optional<T> queryForObject(String sql, Class<T> type) {
        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createQuery(sql)
                        .mapTo(type)
                        .findOne()
        );
    }

    public <T> Optional<T> queryForObject(String sql, Class<T> type, Map<String, Object> params) {
        return jdbiProvider.getJdbi().withHandle(handle -> {
            Query query = handle.createQuery(sql);
            params.forEach(query::bind);
            return query.mapTo(type).findOne();
        });
    }

    public <T> List<T> queryForList(String sql, Class<T> type) {
        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createQuery(sql)
                        .mapTo(type)
                        .list()
        );
    }

    public <T> List<T> queryForList(String sql, Class<T> type, Map<String, Object> params) {
        return jdbiProvider.getJdbi().withHandle(handle -> {
            Query query = handle.createQuery(sql);
            params.forEach(query::bind);
            return query.mapTo(type).list();
        });
    }

    public Long queryForLong(String sql) {
        return queryForObject(sql, Long.class).orElse(0L);
    }

    public Long queryForLong(String sql, Map<String, Object> params) {
        return queryForObject(sql, Long.class, params).orElse(0L);
    }

    public Integer queryForInt(String sql) {
        return queryForObject(sql, Integer.class).orElse(0);
    }

    public Integer queryForInt(String sql, Map<String, Object> params) {
        return queryForObject(sql, Integer.class, params).orElse(0);
    }

    public String queryForString(String sql) {
        return queryForObject(sql, String.class).orElse(null);
    }

    public String queryForString(String sql, Map<String, Object> params) {
        return queryForObject(sql, String.class, params).orElse(null);
    }

    // ========== Update/Execute Operations ==========

    public int executeUpdate(String sql) {
        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createUpdate(sql).execute()
        );
    }

    public int executeUpdate(String sql, Map<String, Object> params) {
        return jdbiProvider.getJdbi().withHandle(handle -> {
            Update update = handle.createUpdate(sql);
            params.forEach(update::bind);
            return update.execute();
        });
    }

    public List<Integer> executeBatch(String sql, List<Map<String, Object>> batchParams) {
        return jdbiProvider.getJdbi().withHandle(handle -> {
            List<Integer> results = new ArrayList<>();
            for (Map<String, Object> params : batchParams) {
                Update update = handle.createUpdate(sql);
                params.forEach(update::bind);
                results.add(update.execute());
            }
            return results;
        });
    }

    // ========== Stored Procedure Operations ==========

    public void callProcedure(String procedureName) {
        jdbiProvider.getJdbi().useHandle(handle ->
                handle.createCall("{call " + procedureName + "()}").invoke()
        );
    }

    public void callProcedure(String procedureName, Map<String, Object> params) {
        jdbiProvider.getJdbi().useHandle(handle -> {
            StringBuilder sql = new StringBuilder("{call ").append(procedureName).append("(");
            sql.append(String.join(",", Collections.nCopies(params.size(), "?")));
            sql.append(")}");

            Call call = handle.createCall(sql.toString());
            params.forEach(call::bind);
            call.invoke();
        });
    }

    public <T> Optional<T> callFunction(String functionName, Class<T> returnType) {
        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createQuery("SELECT " + functionName + "()")
                        .mapTo(returnType)
                        .findOne()
        );
    }

    public <T> Optional<T> callFunction(String functionName, Class<T> returnType, Map<String, Object> params) {
        return jdbiProvider.getJdbi().withHandle(handle -> {
            StringBuilder sql = new StringBuilder("SELECT ").append(functionName).append("(");
            sql.append(String.join(",", params.keySet().stream().map(k -> ":" + k).collect(Collectors.toList())));
            sql.append(")");

            Query query = handle.createQuery(sql.toString());
            params.forEach(query::bind);
            return query.mapTo(returnType).findOne();
        });
    }

    // ========== Transaction Operations ==========

    public void execute(Consumer<Handle> handleConsumer) {
        jdbiProvider.getJdbi().useTransaction(handleConsumer::accept);
    }

    public <T> T executeInTransaction(Function<Handle, T> handleFunction) {
        return jdbiProvider.getJdbi().inTransaction(handleFunction::apply);
    }

    public void executeWithHandle(Consumer<Handle> handleConsumer) {
        jdbiProvider.getJdbi().useHandle(handleConsumer::accept);
    }

    public <T> T withHandle(Function<Handle, T> handleFunction) {
        return jdbiProvider.getJdbi().withHandle(handleFunction::apply);
    }

    // ========== Utility Operations ==========

    public Jdbi getJdbi() {
        return jdbiProvider.getJdbi();
    }

    public <T> RowMapper<T> getRowMapper(Class<T> resultClass) {
        return (resultSet, ctx) -> {
            KurubindRowMapper<T> mapper = new KurubindRowMapper<>(
                    resultClass, handlerRegistry, dialect
            );
            return mapper.map(resultSet, ctx);
        };
    }



    // ========== Pagination ==========

    public <T> PageResult<T> queryPage(Class<T> entityClass, int page, int pageSize) {
        EntityMetadata metadata = new EntityMetadata(entityClass);

        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot page @QueryResponse entities.");
        }

        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateSelect(metadata);

        return queryPage(sql, entityClass, Collections.emptyMap(), page, pageSize);
    }

    public <T> PageResult<T> queryPage(String sql, Class<T> resultClass, int page, int pageSize) {
        return queryPage(sql, resultClass, Collections.emptyMap(), page, pageSize);
    }

    public <T> PageResult<T> queryPage(String sql, Class<T> resultClass, Map<String, Object> params, int page, int pageSize) {
        // Count total results with same parameters
        String countSql = "SELECT COUNT(*) FROM (" + sql + ") AS count_query";
        long total = queryForLong(countSql, params);

        // Build paginated query with dialect-specific syntax
        String pagedSql = buildPaginatedQuery(sql, page, pageSize);

        // Create parameters map with pagination params
        Map<String, Object> allParams = new HashMap<>(params);
        allParams.put("limit", pageSize);
        allParams.put("offset", (page - 1) * pageSize);

        List<T> results = query(pagedSql, resultClass, allParams);

        return new PageResult<>(results, page, pageSize, total);
    }

    private String buildPaginatedQuery(String sql, int page, int pageSize) {
        // All three databases (MySQL, PostgreSQL, SQLite) support LIMIT/OFFSET
        return sql + " LIMIT :limit OFFSET :offset";
    }

    // ========== Value Generation ==========

    private <T> void generateValues(T entity, EntityMetadata metadata, boolean isInsert, boolean isUpdate) {
        for (FieldMetadata field : metadata.getFields()) {
            if (field.hasAnnotation(DefaultValue.class)) {
                DefaultValue defaultValue = field.getAnnotation(DefaultValue.class);
                Object currentValue = field.getValue(entity);

                if (currentValue == null) {
                    if (!defaultValue.value().isEmpty() && !defaultValue.generator().isEmpty()) {
                        throw new IllegalStateException(
                                "Field " + field.getFieldName() + " has both value and generator in @DefaultValue"
                        );
                    }

                    if (!defaultValue.value().isEmpty()) {
                        Object parsedValue = parseLiteral(defaultValue.value(), field.getFieldType());
                        field.setValue(entity, parsedValue);
                    } else if (!defaultValue.generator().isEmpty()) {
                        ValueGenerator generator = valueGeneratorRegistry.getGenerator(defaultValue.generator());
                        Object generatedValue = generator.generate(entity, field);
                        field.setValue(entity, generatedValue);
                    }
                }
            }

            if (field.hasAnnotation(Generated.class)) {
                Generated generated = field.getAnnotation(Generated.class);
                boolean shouldGenerate = (isInsert && generated.onInsert()) ||
                        (isUpdate && generated.onUpdate());

                if (shouldGenerate) {
                    ValueGenerator generator = valueGeneratorRegistry.getGenerator(generated.generator());
                    Object generatedValue = generator.generate(entity, field);
                    field.setValue(entity, generatedValue);
                }
            }
        }
    }

    private Object parseLiteral(String literal, Class<?> targetType) {
        if (targetType == String.class) {
            return literal;
        }
        if (targetType == Integer.class || targetType == int.class) {
            return Integer.parseInt(literal);
        }
        if (targetType == Long.class || targetType == long.class) {
            return Long.parseLong(literal);
        }
        if (targetType == Double.class || targetType == double.class) {
            return Double.parseDouble(literal);
        }
        if (targetType == Float.class || targetType == float.class) {
            return Float.parseFloat(literal);
        }
        if (targetType == Boolean.class || targetType == boolean.class) {
            return Boolean.parseBoolean(literal);
        }
        return literal;
    }

    // ========== Validation ==========

    private <T> void validateEntity(T entity, EntityMetadata metadata) {
        List<ValidationError> errors = new ArrayList<>();

        for (FieldMetadata field : metadata.getFields()) {
            Object value = field.getValue(entity);
            List<Validator> validators = validatorRegistry.getValidators(field);

            for (Validator validator : validators) {
                try {
                    validator.validate(value, field);
                } catch (ValidationException e) {
                    errors.addAll(e.getErrors());
                }
            }
        }

        if (!errors.isEmpty()) {
            throw new ValidationException(errors);
        }
    }

    // ========== Helper Methods ==========

    private List<FieldMetadata> getFieldsForInsert(EntityMetadata metadata) {
        return metadata.getFields().stream()
                .filter(f -> !f.isId() || !metadata.hasAutoGeneratedId())
                .collect(Collectors.toList());
    }

    private void bindFields(Update update, Object entity, List<FieldMetadata> fields) {
        for (FieldMetadata field : fields) {
            Object value = field.getValue(entity);

            List<Handler> handlers = handlerRegistry.getHandlersForField(field, dialect);
            for (Handler handler : handlers) {
                value = handler.handleWrite(value, field);
            }

            update.bind(field.getColumnName(), value);
        }
    }

    // ========== Nested Classes ==========

    public static class PageResult<T> {
        private final List<T> results;
        private final int page;
        private final int pageSize;
        private final long totalElements;
        private final long totalPages;

        public PageResult(List<T> results, int page, int pageSize, long totalElements) {
            this.results = results;
            this.page = page;
            this.pageSize = pageSize;
            this.totalElements = totalElements;
            this.totalPages = (totalElements + pageSize - 1) / pageSize;
        }

        public List<T> getResults() { return results; }
        public int getPage() { return page; }
        public int getPageSize() { return pageSize; }
        public long getTotalElements() { return totalElements; }
        public long getTotalPages() { return totalPages; }
        public boolean hasNext() { return page < totalPages; }
        public boolean hasPrevious() { return page > 1; }

        @Override
        public String toString() {
            return "PageResult{" +
                    "results=" + results +
                    ", page=" + page +
                    ", pageSize=" + pageSize +
                    ", totalElements=" + totalElements +
                    ", totalPages=" + totalPages +
                    '}';
        }
    }

    // ========== Builder ==========

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private JdbiProvider jdbiProvider;
        private HandlerRegistry handlerRegistry = new HandlerRegistry();
        private SQLGeneratorRegistry sqlGeneratorRegistry = new SQLGeneratorRegistry();
        private ValidatorRegistry validatorRegistry = new ValidatorRegistry();
        private ValueGeneratorRegistry valueGeneratorRegistry = new ValueGeneratorRegistry();
        private Dialect dialect;

        public Builder withJdbi(Jdbi jdbi) {
            this.jdbiProvider = () -> jdbi;
            return this;
        }

        public Builder withJdbiProvider(JdbiProvider jdbiProvider) {
            this.jdbiProvider = jdbiProvider;
            return this;
        }

        public Builder withHandlerRegistry(HandlerRegistry handlerRegistry) {
            this.handlerRegistry = handlerRegistry;
            return this;
        }

        public Builder withSQLGeneratorRegistry(SQLGeneratorRegistry sqlGeneratorRegistry) {
            this.sqlGeneratorRegistry = sqlGeneratorRegistry;
            return this;
        }

        public Builder withValidatorRegistry(ValidatorRegistry validatorRegistry) {
            this.validatorRegistry = validatorRegistry;
            return this;
        }

        public Builder withValueGeneratorRegistry(ValueGeneratorRegistry valueGeneratorRegistry) {
            this.valueGeneratorRegistry = valueGeneratorRegistry;
            return this;
        }

        public Builder withDialect(Dialect dialect) {
            this.dialect = dialect;
            return this;
        }

        public KurubindDatabase build() {
            if (jdbiProvider == null) {
                throw new IllegalStateException("JDBI or JdbiProvider must be provided");
            }
            return new KurubindDatabase(this);
        }
    }
}
