package com.roelias.kurubind;

import com.roelias.kurubind.annotations.DefaultValue;
import com.roelias.kurubind.annotations.Generated;
import com.roelias.kurubind.core.*;
import com.roelias.kurubind.exceptions.ValidationError;
import com.roelias.kurubind.exceptions.ValidationException;
import com.roelias.kurubind.mapper.KurubindRowMapper;
import com.roelias.kurubind.metadata.EntityMetadata;
import com.roelias.kurubind.metadata.FieldMetadata;
import com.roelias.kurubind.registry.HandlerRegistry;
import com.roelias.kurubind.registry.SQLGeneratorRegistry;
import com.roelias.kurubind.registry.ValidatorRegistry;
import com.roelias.kurubind.registry.ValueGeneratorRegistry;
import org.jdbi.v3.core.Handle;
import org.jdbi.v3.core.Jdbi;
import org.jdbi.v3.core.statement.Update;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Collectors;

public class KurubindDatabase {
    private final JdbiProvider jdbiProvider;
    private final HandlerRegistry handlerRegistry;
    private final SQLGeneratorRegistry sqlGeneratorRegistry;
    private final ValidatorRegistry validatorRegistry;
    private final ValueGeneratorRegistry valueGeneratorRegistry;
    private final Dialect dialect;

    private KurubindDatabase(Builder builder) {
        this.jdbiProvider = builder.jdbiProvider;
        this.handlerRegistry = builder.handlerRegistry;
        this.sqlGeneratorRegistry = builder.sqlGeneratorRegistry;
        this.validatorRegistry = builder.validatorRegistry;
        this.valueGeneratorRegistry = builder.valueGeneratorRegistry;
        this.dialect = builder.dialect;
    }

    // ========== CRUD Operations ==========

    public <T> void insert(T entity) {
        EntityMetadata metadata = new EntityMetadata(entity.getClass());
        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot insert @QueryResponse entities");
        }
        generateValues(entity, metadata, true, false);
        validateEntity(entity, metadata);
        List<FieldMetadata> fieldsToInsert = getFieldsForInsert(metadata);
        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateInsert(metadata, fieldsToInsert);
        execute(handle -> {
            Update update = handle.createUpdate(sql);
            bindFields(update, entity, fieldsToInsert);

            if (metadata.hasAutoGeneratedId()) {
                // Recuperar ID generado
                Object generatedId = update.executeAndReturnGeneratedKeys(metadata.getIdField().getColumnName())
                        .mapTo(metadata.getIdField().getFieldType())
                        .one();
                metadata.getIdField().setValue(entity, generatedId);
            } else {
                update.execute();
            }
        });
    }

    public <T> void insertAll(List<T> entities) {
        for (T entity : entities) {
            insert(entity);
        }
    }

    public <T> void update(T entity) {
        EntityMetadata metadata = new EntityMetadata(entity.getClass());

        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot update @QueryResponse entities");
        }

        if (!metadata.hasIdField()) {
            throw new IllegalArgumentException("Entity must have @Id field for update");
        }

        // 1. Generar valores
        generateValues(entity, metadata, false, true);

        // 2. Validar
        validateEntity(entity, metadata);

        // 3. Preparar SQL
        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateUpdate(metadata, metadata.getFields());

        // 4. Ejecutar
        execute(handle -> {
            Update update = handle.createUpdate(sql);
            bindFields(update, entity, metadata.getNonIdFields());
            update.bind(metadata.getIdField().getColumnName(),
                    metadata.getIdField().getValue(entity));
            update.execute();
        });
    }

    public <T> void delete(T entity) {
        EntityMetadata metadata = new EntityMetadata(entity.getClass());

        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot delete @QueryResponse entities");
        }

        if (!metadata.hasIdField()) {
            throw new IllegalArgumentException("Entity must have @Id field for delete");
        }

        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateDelete(metadata);

        execute(handle -> {
            handle.createUpdate(sql)
                    .bind(metadata.getIdField().getColumnName(),
                            metadata.getIdField().getValue(entity))
                    .execute();
        });
    }

    public <T> void deleteAll(List<T> entities) {
        for (T entity : entities) {
            delete(entity);
        }
    }

    // ========== Query Operations ==========

    public <T> List<T> list(Class<T> entityClass) {
        EntityMetadata metadata = new EntityMetadata(entityClass);

        if (metadata.isQueryResponse()) {
            throw new IllegalArgumentException("Cannot list @QueryResponse entities. Use query() instead.");
        }

        SQLGenerator generator = sqlGeneratorRegistry.getGenerator(dialect);
        String sql = generator.generateSelect(metadata);

        return query(sql, entityClass);
    }

    public <T> List<T> query(String sql, Class<T> resultClass) {
        KurubindRowMapper<T> mapper = new KurubindRowMapper<>(
                resultClass, handlerRegistry, dialect
        );

        return jdbiProvider.getJdbi().withHandle(handle ->
                handle.createQuery(sql)
                        .map(mapper)
                        .list()
        );
    }

    public void execute(Consumer<Handle> handleConsumer) {
        // Note: The Consumer cannot throw checked exceptions itself.
        // Any checked exceptions from JDBI will be wrapped in runtime exceptions.
        jdbiProvider.getJdbi().useHandle(handleConsumer::accept);
    }

    public Jdbi getJdbi(){
            return jdbiProvider.getJdbi();
    }

    // ========== Value Generation ==========

    private <T> void generateValues(T entity, EntityMetadata metadata, boolean isInsert, boolean isUpdate) {
        for (FieldMetadata field : metadata.getFields()) {
            // Procesar @DefaultValue
            if (field.hasAnnotation(DefaultValue.class)) {
                DefaultValue defaultValue = field.getAnnotation(DefaultValue.class);
                Object currentValue = field.getValue(entity);

                if (currentValue == null) {
                    if (!defaultValue.value().isEmpty() && !defaultValue.generator().isEmpty()) {
                        throw new IllegalStateException(
                                "Field " + field.getFieldName() + " has both value and generator in @DefaultValue"
                        );
                    }

                    if (!defaultValue.value().isEmpty()) {
                        // Usar valor literal
                        Object parsedValue = parseLiteral(defaultValue.value(), field.getFieldType());
                        field.setValue(entity, parsedValue);
                    } else if (!defaultValue.generator().isEmpty()) {
                        // Usar generator
                        ValueGenerator generator = valueGeneratorRegistry.getGenerator(defaultValue.generator());
                        Object generatedValue = generator.generate(entity, field);
                        field.setValue(entity, generatedValue);
                    }
                }
            }

            // Procesar @Generated
            if (field.hasAnnotation(Generated.class)) {
                Generated generated = field.getAnnotation(Generated.class);
                boolean shouldGenerate = (isInsert && generated.onInsert()) ||
                        (isUpdate && generated.onUpdate());

                if (shouldGenerate) {
                    ValueGenerator generator = valueGeneratorRegistry.getGenerator(generated.generator());
                    Object generatedValue = generator.generate(entity, field);
                    field.setValue(entity, generatedValue);
                }
            }
        }
    }

    private Object parseLiteral(String literal, Class<?> targetType) {
        if (targetType == String.class) {
            return literal;
        }
        if (targetType == Integer.class || targetType == int.class) {
            return Integer.parseInt(literal);
        }
        if (targetType == Long.class || targetType == long.class) {
            return Long.parseLong(literal);
        }
        if (targetType == Double.class || targetType == double.class) {
            return Double.parseDouble(literal);
        }
        if (targetType == Float.class || targetType == float.class) {
            return Float.parseFloat(literal);
        }
        if (targetType == Boolean.class || targetType == boolean.class) {
            return Boolean.parseBoolean(literal);
        }
        return literal;
    }

    // ========== Validation ==========

    private <T> void validateEntity(T entity, EntityMetadata metadata) {
        List<ValidationError> errors = new ArrayList<>();

        for (FieldMetadata field : metadata.getFields()) {
            Object value = field.getValue(entity);
            List<Validator> validators = validatorRegistry.getValidators(field);

            for (Validator validator : validators) {
                try {
                    validator.validate(value, field);
                } catch (ValidationException e) {
                    errors.addAll(e.getErrors());
                }
            }
        }

        if (!errors.isEmpty()) {
            throw new ValidationException(errors);
        }
    }

    // ========== Helper Methods ==========

    private List<FieldMetadata> getFieldsForInsert(EntityMetadata metadata) {
        return metadata.getFields().stream()
                .filter(f -> !f.isId() || !metadata.hasAutoGeneratedId())
                .collect(Collectors.toList());
    }

    private void bindFields(Update update, Object entity, List<FieldMetadata> fields) {
        for (FieldMetadata field : fields) {
            Object value = field.getValue(entity);

            // Aplicar handlers de escritura
            List<Handler> handlers = handlerRegistry.getHandlersForField(field, dialect);
            for (Handler handler : handlers) {
                value = handler.handleWrite(value);
            }

            update.bind(field.getColumnName(), value);
        }
    }

    // ========== Builder ==========

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private JdbiProvider jdbiProvider;
        private HandlerRegistry handlerRegistry = new HandlerRegistry();
        private SQLGeneratorRegistry sqlGeneratorRegistry = new SQLGeneratorRegistry();
        private ValidatorRegistry validatorRegistry = new ValidatorRegistry();
        private ValueGeneratorRegistry valueGeneratorRegistry = new ValueGeneratorRegistry();
        private Dialect dialect;

        public Builder withJdbi(Jdbi jdbi) {
            this.jdbiProvider = () -> jdbi;
            return this;
        }

        public Builder withJdbiProvider(JdbiProvider jdbiProvider) {
            this.jdbiProvider = jdbiProvider;
            return this;
        }

        public Builder withHandlerRegistry(HandlerRegistry handlerRegistry) {
            this.handlerRegistry = handlerRegistry;
            return this;
        }

        public Builder withSQLGeneratorRegistry(SQLGeneratorRegistry sqlGeneratorRegistry) {
            this.sqlGeneratorRegistry = sqlGeneratorRegistry;
            return this;
        }

        public Builder withValidatorRegistry(ValidatorRegistry validatorRegistry) {
            this.validatorRegistry = validatorRegistry;
            return this;
        }

        public Builder withValueGeneratorRegistry(ValueGeneratorRegistry valueGeneratorRegistry) {
            this.valueGeneratorRegistry = valueGeneratorRegistry;
            return this;
        }

        public Builder withDialect(Dialect dialect) {
            this.dialect = dialect;
            return this;
        }

        public KurubindDatabase build() {
            if (jdbiProvider == null) {
                throw new IllegalStateException("JDBI or JdbiProvider must be provided");
            }
            return new KurubindDatabase(this);
        }
    }
}
