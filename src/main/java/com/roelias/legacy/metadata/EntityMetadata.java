package com.roelias.legacy.metadata;

import com.roelias.legacy.annotations.*;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class EntityMetadata {


    private final Class<?> entityClass;
    private final String tableName;
    private String schema;
    private final List<FieldMetadata> fields;
    private final FieldMetadata idField;
    private final boolean isQueryResponse;


    public EntityMetadata(Class<?> entityClass) {
        this.entityClass = entityClass;
        this.isQueryResponse = entityClass.isAnnotationPresent(QueryResponse.class);
        if (!isQueryResponse) {
            Table tableAnnotation = entityClass.getAnnotation(Table.class);
            if (tableAnnotation == null) {
                throw new IllegalArgumentException("Class " + entityClass.getName() + " must be annotated with @Table or @QueryResponse");
            }
            this.tableName = tableAnnotation.value();
            this.schema = tableAnnotation.schema();
        } else {
            this.tableName = null;
            this.schema = null;
        }
        this.fields = new ArrayList<>();
        FieldMetadata foundIdField = null;
        Class<?> currentClass = entityClass;
        while (currentClass != null && currentClass != Object.class) {
            for (Field field : currentClass.getDeclaredFields()) {

                if (fields.stream().anyMatch(f -> f.getFieldName().equals(field.getName()))) {
                    continue;
                }
                if (field.isAnnotationPresent(Transient.class)) {
                    continue;
                }
                if (field.isAnnotationPresent(Column.class)) {
                    FieldMetadata fieldMetadata = new FieldMetadata(field);
                    fields.add(fieldMetadata);
                    if (fieldMetadata.isId()) {
                        if (foundIdField != null) {
                            throw new IllegalArgumentException("Class " + entityClass.getName() + " has multiple @Id fields");
                        }
                        foundIdField = fieldMetadata;
                    }
                }
            }
            currentClass = currentClass.getSuperclass();
        }

        this.idField = foundIdField;

    }

    public Class<?> getEntityClass() {
        return entityClass;
    }

    public String getTableName() {
        return tableName;
    }

    public String getSchema() {
        return schema;
    }

    public String getFullTableName() {
        if (schema == null || schema.isEmpty()) {
            return tableName;
        }
        return schema + "." + tableName;
    }

    public List<FieldMetadata> getFields() {
        return Collections.unmodifiableList(fields);
    }

    public List<FieldMetadata> getNonIdFields() {
        return fields.stream()
                .filter(f -> !f.isId())
                .collect(Collectors.toList());
    }

    public FieldMetadata getIdField() {
        return idField;
    }

    public boolean hasIdField() {
        return idField != null;
    }

    public boolean hasAutoGeneratedId() {
        if (idField == null) {
            return false;
        }
        Id idAnnotation = idField.getAnnotation(Id.class);
        return idAnnotation != null && idAnnotation.autogenerate();
    }

    public boolean isQueryResponse() {
        return isQueryResponse;
    }

    public Object createInstance() {
        try {
            return entityClass.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Failed to create instance of " + entityClass.getName(), e);
        }
    }

}
